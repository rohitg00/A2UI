# Proposal: GULF Schema Layers

# Aim

Propose updates to the GULF protocol so that it fully supports the functionality of the Flutter Gen UI SDK and we can migrate our SDK to be built on top of GULF.

# Requirements

*   **Support custom component catalogs**: Clients and server should be able to use GULF with a custom component catalog that is known to both of them and is identified by a name.
*   **Support dynamically negotiated components**: Clients can dynamically send their local custom component library to the server to use, if the server chooses to support this. This is especially useful for local development workflows, and integrations where there is a high level of trust between agent and client.
*   **Provide a strict schema for the LLM**: The LLM should see a GULF schema which provides the same degree of strictness as GULF v0.7, i.e. the LLM should see a schema which specifies all the possible parameters of every widget in the catalog.
*   **Standardized component catalog format**: We need to standardize the way component catalogs are expressed so that agent logic can easily generate LLM format schemas from them.

# Overview

The overall direction of this proposal is to extend and modularize the formal GULF protocol schema to make it more flexible and extensible. By separating the core protocol—the fundamental message types and structures—from the specific UI components and styling rules, we can support a wider range of use cases and client capabilities. This layered approach allows for greater customization while maintaining a consistent foundation for communication between servers and clients.

The rationale for this is:

*   Make the wire format agnostic to the catalog so that developers can use custom catalogs. This is the core premise of go/genui-sdk-proposal from the Flutter team, so we need this to be able to adopt GULF in our SDK.
*   Allows LLMs to author UIs in a different format to the wire format, because the requirements of the wire format (simple for humans to understand, standard across all agents) are slightly different from the LLM format (easy to for LLM to understand, can be tailored to each agent or model).

## Interaction

1. (optional) Client fetches the server’s agent card to check server capabilities. This will contain the A2A-UI AgentExtension within AgentCapabilities, which will declare what schemas it supports. If the client doesn't do this and requests an unavailable catalog, then the ClientCapabilities request may fail.
2. (optional) If using custom components, the client makes a ClientCapabilities message to the server to specific which catalog to use. If this message is not sent, the agent will use the standard catalog for the particular GULF protocol version.
3. Client sends some prompt
4. Agent responds with a combination of ComponentUpdate, DataModelUpdate, SurfaceUpdate and DeleteSurface messages.
5. The client will clientEvent messages with a userAction item when any UI interactions occur.

## New Concepts

#### Surfaces

A **Surface** is a contiguous portion of screen real estate into which a GULF UI can be rendered. The protocol introduces the concept of a `surfaceId` to uniquely identify and manage these areas. This allows a single GULF stream to control multiple, independent UI regions simultaneously. Each surface has a separate root component and a separate hierarchy of components. All surfaces share the same data model, to allow displaying the same data in different ways across multiple surfaces.

For example, in a chat application, each AI-generated response could be rendered into a separate surface within the conversation history. A separate, persistent surface could be used for a side panel that displays related information.

The `surfaceId` is used in `SurfaceUpdate` messages to direct component changes to the correct area, and the `DeleteSurface` message allows for explicitly removing a surface and its contents from the UI.

In a multi-surface system, the client will send messages to the agent to describe what surfaces are avialable to render to and provide their surfaceIds. For more simple, single-surface interactions, there is the concept of the "default" surface which is used if no `surfaceId` is specified by the agent. In this case, the client must have an implicit behavior 

## Updates to schemas and formats

#### Server-to-Client Protocol Schema (updated)

A standard protocol that allows agents to send UI to surfaces.

This is what we already designed, but the proposal is to:
- Make it generic to the component catalog, to allow for custom components.
- Add a **Data Binding Shorthand** to allow initializing the data model and binding to it in a single step.

#### Client-to-Server Event Schema (updated)

The protocol to allow clients to send messages to agents. This includes user-initiated actions, capability declarations, and error reports.

#### Catalog Schema (new)

A schema used to represent a catalog of components that are available. This is used to represent the standard catalog and custom catalogs. This is to allow us to split out the specific catalog definition from the protocol schema.

#### LLM Schema

The schema that is actually passed to the LLM by the agent, which is specific to the catalog being used. When you combine the generic Client Protocol Schema and the Standard Catalog Definition, you should be able to produce an LLM schema _exactly_ the same as the v0.7 protocol.

#### AgentExtension format

We define how the ‘params’ of the AgentExtension declaration in the Agent Card will be used to declare the capabilities.

## Updated data objects

#### Split out the Standard Catalog Definition (new)

An object which represents the standard GULF catalog, conforming to the Catalog Schema. This is the actual standard catalog of widgets that we agreed on e.g. Text, Heading, Row etc.

#### Changes to the standard catalog

We will update the standard catalog in the following ways:
*   **Image `fit` Property**: A new `fit` property for the `Image` component to control how the image is resized.
*   **Markdown in `Text`**: The `Text` component now officially supports markdown.

## Proposed components

#### Custom Schema Adapter

The schema adapter is an agent-side utility that can accept a custom widget catalog and convert it to a schema which allows the LLM to generate `surfaceUpdate` messages for a particular catalog reliably.

# Detailed design

### Catalog schema

This schema is used to define Catalogs of available components, including the available properties of each component. The schema for this is:

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "GULF Catalog",
  "description": "A schema that defines a catalog of GULF components and styles.",
  "type": "object",
  "properties": {
    "components": {
      "title": "GULF Components",
      "description": "A schema that defines a catalog of GULF components. Each key is a component name, and each value is the JSON schema for that component's properties.",
      "type": "object",
      "additionalProperties": {
        "$ref": "https://json-schema.org/draft/2020-12/schema"
      }
    },
    "styles": {
      "title": "GULF Styles",
      "description": "A schema that defines a catalog of GULF styles. Each key is a style name, and each value is the JSON schema for that style's properties.",
      "type": "object",
      "additionalProperties": {
        "$ref": "https://json-schema.org/draft/2020-12/schema"
      }
    }
  },
  "required": [
    "components",
    "styles"
  ]
}
```

### Server-to-Client Protocol Schema

This is based on the four message types defined in v0.7 but makes the following changes:

*   Formally combines the four messages into a single message. This shows how they can be included in an A2A message.
*   Adds the concept of a `surfaceId` to `componentUpdate` and a new `deleteSurface` message. This allows the protocol to manage multiple independent UI surfaces (e.g., a main view and a side panel) over a single connection. The `surfaceId` directs updates to the correct UI area, and `deleteSurface` allows for explicitly closing or dismissing a surface.
*   Replaces the detailed `componentProperties` in `componentUpdate` with a generic object. The available components and their properties are no longer defined in the protocol itself but in a separate `Catalog` definition.
*   Moves styling definitions out of the core protocol and into the `Catalog`. The `styles` object in the `beginRendering` message is now a generic object, allowing the server to send any key-value pairs that are defined in the active catalog's `styles` section. This makes styling extensible, just like components.

```json
{
  "title": "GULF Protocol message",
  "description": "A message from the server to the client, which can be one of several types.",
  "properties": {
    "beginRendering": {
      "title": "BeginRendering Message",
      "description": "A schema for a BeginRendering message in the A2A streaming UI protocol. This message signals that the UI can now be rendered and provides initial root component and styling information.",
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "The ID of the root component from which rendering should begin. This is a reference to a component instance by its unique ID. This property is REQUIRED."
        },
        "styles": {
          "type": "object",
          "description": "An object containing styling information for the UI.",
          "additionalProperties": true
        }
      },
      "required": [
        "root",
        "type"
      ]
    },
    "updateSurface": {
      "title": "updateSurface Message",
      "description": "A schema for a SurfaceUpdate message in the A2A streaming UI protocol.",
      "type": "object",
      "properties": {
        "surfaceId": {
          "type": "string",
          "description": "An ID for the surface that the UI changes should be applied to. If this surface doesn't exist, it will be created. If this is not specified, the default surface will be used."
        },
        "components": {
          "type": "array",
          "description": "A flat list of all component instances available for rendering. Components reference each other by ID. This property is REQUIRED.",
          "items": {
            "description": "A specific instance of a ComponentType with its own unique ID and properties.",
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "A unique identifier for this component instance. This property is REQUIRED."
              },
              "componentProperties": {
                "type": "object",
                "description": "Defines the properties for the component type.",
                "additionalProperties": true
              }
            },
            "required": [
              "id",
              "componentProperties"
            ]
          }
        }
      },
      "required": [
        "components",
        "type"
      ]
    },
    "dataModelUpdate": {
      "title": "Data model update",
      "description": "Sets or replaces the data model at a specified path with new content.",
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "An optional path to a location within the data model where the content should be inserted or replaced. The path is represented as a dot-separated string and can include array indexing (e.g., 'user.addresses[0].street'). If this field is omitted, the entire data model will be replaced with the provided 'contents'."
        },
        "contents": {
          "description": "The JSON content to be placed at the specified path. This property is REQUIRED. This can be any valid JSON value (object, array, string, number, boolean, or null). The content at the target path will be completely replaced by this new value."
        }
      },
      "required": [
        "contents",
        "type"
      ]
    },
    "deleteSurface": {
      "title": "DeleteSurface Message",
      "description": "A schema for a DeleteSurface message in the A2A streaming UI protocol. This message signals that a surface should be removed from the UI.",
      "type": "object",
      "properties": {
        "surfaceId": {
          "type": "string",
          "description": "The ID of the surface to be deleted. This property is REQUIRED."
        }
      },
      "required": [
        "surfaceId"
      ]
    }
  }
}
```

### Client-to-Server Event Schema

The client sends messages to the server to report user actions, declare capabilities, or send error information. The schema defines three main message types:

*   `userAction`: Sent when the user interacts with a component that has an action defined. It includes the action name and any resolved context data.
*   `clientCapabilities`: Sent by the client to inform the server about its capabilities, such as the component catalog it supports. The client can either reference a known catalog by URI or provide a dynamic catalog definition directly.
*   `error`: Sent when the client encounters an error, for instance, during UI rendering or data binding. This provides a feedback mechanism for the server.

```json
{
  "title": "GULF Client Event Message",
  "description": "A message sent from the client to the server. Exactly ONE of the properties in this object must be set.",
  "type": "object",
  "properties": {
    "userAction": {
      "title": "User Action",
      "description": "Represents a user-initiated action, sent from the client to the server.",
      "type": "object",
      "properties": {
        "actionName": {
          "type": "string",
          "description": "The name of the action, taken from the component's `action.action` property."
        },
        "sourceComponentId": {
          "type": "string",
          "description": "The `id` of the component that triggered the event."
        },
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "An ISO 8601 timestamp of when the event occurred."
        },
        "resolvedContext": {
          "type": "object",
          "description": "A JSON object containing the key-value pairs from the component's `action.context`, after resolving all data bindings.",
          "additionalProperties": true
        }
      },
      "required": [
        "actionName",
        "sourceComponentId",
        "timestamp",
        "resolvedContext"
      ]
    },
    "clientCapabilities": {
      "title": "Client Capabilities",
      "description": "A message from the client describing its capabilities, such as the component catalog it supports. Exactly ONE of the properties in this object must be set.",
      "type": "object",
      "properties": {
        "catalogUri": {
          "type": "string",
          "description": "A URI pointing to a predefined component catalog schema."
        },
        "dynamicCatalog": {
          "$ref": "https://raw.githubusercontent.com/google/gulf/refs/heads/main/schemas/v0.1/catalog.json"
        }
      },
      "oneOf": [
        {
          "required": [
            "catalogUri"
          ]
        },
        {
          "required": [
            "dynamicCatalog"
          ]
        }
      ]
    },
    "error": {
      "title": "Client Error",
      "description": "A message from the client indicating an error occurred, for example, during UI rendering.",
      "type": "object",
      "additionalProperties": true
    }
  }
}
```

### Data Binding and Initialization Shorthand

To simplify the generation of UIs, especially for LLMs, we propose a shorthand for data binding that also allows for initializing the data model.

Currently, to display a dynamic value that has a default, the server must send two separate messages:
1.  A `dataModelUpdate` message to set the initial value in the data model.
2.  An `updateSurface` message with a component that has a property bound to that data model path.

The proposed shorthand combines these two steps. When a component property that accepts a `BoundValue` (e.g., `text`, `value`) is defined with *both* a `path` and a `literal*` value (e.g., `literalString`), it should be interpreted as follows:

1.  The client's data model is updated at the specified `path` with the provided `literal*` value. This is equivalent to the client implicitly receiving a `dataModelUpdate` for that path.
2.  The component property is then bound to that `path` for future updates.

**Example:**

Instead of sending two messages:
```jsonl
{"dataModelUpdate": {"path": "form.name", "contents": "John Doe"}}
{"updateSurface": {"components": [{"id": "name_field", "componentProperties": {"TextField": {"text": {"path": "form.name"}}}}]}}
```

The server can send a single message:
```jsonl
{"updateSurface": {"components": [{"id": "name_field", "componentProperties": {"TextField": {"text": {"path": "form.name", "literalString": "John Doe"}}}}]}}
```

This reduces verbosity and simplifies the logic for the server-side generation, making the protocol more "LLM-friendly". The client implementation must ensure that this implicit data model update happens before the component is rendered. This change does not alter the schema of the `BoundValue` object, but rather clarifies the client's expected behavior when both properties are present.

### Image `fit` Property

To provide more control over how images are displayed, the `Image` component will be updated to include a `fit` property. This property is a string enum that determines how the image should be resized to fit its container. The possible values are derived from the concepts of `BoxFit` in Flutter and `object-fit` in CSS.

The supported values are:
- `fill`: (Default) The image is resized to fill the container, without preserving the aspect ratio.
- `cover`: The image preserves its aspect ratio and fills the container, cropping any overflowing content.
- `contain`: The image preserves its aspect ratio and is scaled to fit inside the container, which may leave empty space.
- `none`: The image is not resized at all.
- `scale-down`: The image is scaled down to the smaller of `none` or `contain`.

This addition will be reflected in the standard catalog and the LLM schema.

### Markdown Support in `Text` Component

To enhance the richness of the content that can be displayed, the `Text` component will now officially support markdown. The `text` property of the `Text` component will be updated to clarify that its content will be rendered as markdown, allowing for formatting such as bold, italics, lists, and links.

# Extensions

## Formalized AgentExtension example

We could define how an AgentExtension can use parameters to declare what schemas it supports, so that a client can understand whether it can connect to it and what schemas it can choose from.

The AgentExtension declaration includes params:

*   `supportedSchemas`: defines which UI schema versions are supported by the agent.
*   `acceptsDynamicSchemas`: defines whether the agent can accept dynamic schemas propagated from the client, e.g. details of additional custom components that can be used.

```json
{
  "name": "Restaurant finder",
  "capabilities": {
    "extensions": [
      {
        "uri": "https://gulf.org/ext/a2a-ui/v0.1",
        "description": "Ability to render GULF UI",
        "required": false,
        "params": {
          "supportedSchemas": [
            "https://raw.githubusercontent.com/google/gulf/refs/heads/main/schemas/v0.1/standard_catalog.json"
          ],
          "acceptsDynamicSchemas": true
        }
      }
    ]
  }
}
```

### Catalog Building blocks

The standard catalog contains some subschemas which would benefit from being reused by custom components, to ensure consistency of practices in defining component hierarchies, binding to the data model, and defining actions.

We could separate out these subschemas into individual files with uris that can be referenced by custom schemas, to ensure consistency of structure. This consistency would make it easier to implement renderers that support custom components, or generic validators which can parse LLM output and check that the references between components are valid etc without attempting actual rendering.

#### stringReference.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://raw.githubusercontent.com/google/gulf/refs/heads/main/schemas/v0.1/stringReference.json",
  "title": "String Reference",
  "description": "A reference that can either be a data model path or a literal string.",
  "type": "object",
  "properties": {
    "path": {
      "type": "string",
      "description": "A data binding reference to a location in the data model (e.g., '/user/name')."
    },
    "literalString": {
      "type": "string",
      "description": "A fixed, hardcoded string value."
    }
  }
}
```

#### booleanReference.json

As above, but with:

```json
"literalBoolean": { "type": "boolean" }
```

#### numberReference.json

As above, but with:

```json
"literalNumber": {
  "type": "number"
}
```

#### componentReference.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://raw.githubusercontent.com/google/gulf/refs/heads/main/schemas/v0.1/componentReference.json",
  "title": "Component Reference",
  "description": "A reference to a single component instance by its unique ID.",
  "type": "string"
}
```

#### componentArrayReference.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://raw.githubusercontent.com/google/gulf/refs/heads/main/schemas/v0.1/componentArrayReference.json",
  "title": "Component Array Reference",
  "description": "Defines a list of child components, either explicitly or via a data-bound template.",
  "type": "object",
  "properties": {
    "explicitList": {
      "type": "array",
      "description": "An explicit list of component instance IDs.",
      "items": {
        "$ref": "https://raw.githubusercontent.com/google/gulf/refs/heads/main/schemas/v0.1/componentReference.json"
      }
    },
    "template": {
      "type": "object",
      "description": "A template to be rendered for each item in a data-bound list.",
      "properties": {
        "componentId": {
          "type": "string",
          "description": "The ID of the component (from the main 'components' list) to use as a template for each item."
        },
        "dataBinding": {
          "type": "string",
          "description": "A data binding reference to a list within the data model (e.g., '/user/posts')."
        }
      },
      "required": [
        "componentId",
        "dataBinding"
      ]
    }
  }
}
```

#### action.json

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://raw.githubusercontent.com/google/gulf/refs/heads/main/schemas/v0.1/action.json",
  "title": "Action",
  "description": "Represents a user-initiated action.",
  "type": "object",
  "properties": {
    "action": {
      "type": "string",
      "description": "A unique name identifying the action (e.g., 'submitForm')."
    },
    "context": {
      "type": "array",
      "description": "A key-value map of data bindings to be resolved when the action is triggered.",
      "items": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "object",
            "description": "The dynamic value. Define EXACTLY ONE of the nested properties.",
            "properties": {
              "path": {
                "type": "string",
                "description": "A data binding reference to a location in the data model (e.g., '/user/name')."
              },
              "literalString": {
                "type": "string",
                "description": "A fixed, hardcoded string value."
              },
              "literalNumber": {
                "type": "number"
              },
              "literalBoolean": {
                "type": "boolean"
              }
            }
          }
        },
        "required": [
          "key",
          "value"
        ]
      }
    }
  },
  "required": [
    "action"
  ]
}
```
